과정평가일
05/13 : 정보능력
05/24 : 프로그래밍언어응용
06/20 : 프로그래밍언어활용
06/28 : 응용SW기초기술활용
07/02 : 개발자 환경 구축
07/11 : 요구사항확인
07/23 : 화면설계
08/07 : 화면구현
08/19 : UI테스트
08/29 : 데이터입출력구현
09/25 : SQL활용
10/23 : 서버프로그램구현
11/12 : 네트워크프로그래밍
11/29 : 애플리케이션테스트
12/10 : 애플리케이션배포

        // git 무료 서버
        // https://github.com/
        // https://gitlab.com/
        // https://bitbucket.org/

        // git 무료 클라이언트
        // https://tortoisegit.org/
        // https://www.sourcetreeapp.com/
        // https://desktop.github.com/

GIT Repository 1개는 1개의 프로젝트를 저장하는게 원칙입니다.
그러나 파일을 보관하거나 여러개의 프로젝트를 저장하는 경우도 있습니다. 이럴때는 CI/CD 를 사용하기 어렵습니다.


MVC 
Model
View
Controller

Spring framework 5, Spring Boot 3.x
Egov framework
PHP Laravel
Python Django


언어의 조건문 (if, if ~ else ~, if ~ else if ~ else if ~ else ~ , switch/break)
continue : 조건문 검사하기 위하여 올라간다.
break : 블록을 빠져 나갑니다.
return : 메소드(함수를) 빠져 나갑니다.

조건식 : 논리값이 필요해요.

if ( 조건식 ) {
        조건식이 참일 경우에 실행해요.
        ....
        {

        }
}

if ( 조건식 ) 문장;
if ( 조건식 )
    문장;

if ( 거짓 ) {
        1;
} else if ( 거짓 ) {
        2;
} else if ( 참 ) {
        3;
        if ( 거짓 ) {
                6;
        } else {
                7;
        }
} else if ( 참 ) {
        4;
} else {
        5;
}




switch ( 데이터[변수/리턴값있는메소드] ) {
        case 값1 :
                문장;
                문장;
                break;
        case 값2 :
                문장;
                문장;
        case 값3 :
        case 값4 :
                문장;
                break;
        default :
                문장;
                문장;
}
데이터가 값1/값2/값3 일때 해당 지역의 문장을 실행한다.
break; 를 만나면 빠져나간다.
해당하는 값이 없으면 default 지역의 문장을 실행한다.


switch (월) {
        case 1:
        case 3:
        case 5:
        case 7:
        case 8:
        case 10:
        case 12:
                31 일로 처리;
                break;
        case 2:
                윤년계산으로 처리;
                break;
        default:
                30 일로 처리
}




언어의 반복문 (Loop)

for 반복문
for (초기식1,초기식2,...; 조건식; 증감식1, 증감식2,..) {
        실행할 반복문들...
}
1. 초기식 실행
2. 조건식 검사하여 거짓이면 Loop 종료
3. 실행할 반복문들 실행한다.
4. 증감식 실행
2.
3.
4.
2.
3.
4......

for ( int i = 10; i > 0; i-- ) {
        계산 실행 반복문장들
}
i = 10
i(10) > 0 => 참
반복문장들 실행
i--
i(9) > 0 => 참
반복문장들 실행

for (;;) {

}


while 반복문

while ( 조건식 ) {
        반복 문장들
}
1. 조건식이 참이면 반복문장들 실행
2. 반복문장들을 실행하고 다시 조건식을 검증하러 위로 올라간다.
1. 조건식이 참이면 반복문장들 실행
2. 반복문장들을 실행하고 다시 조건식을 검증하러 위로 올라간다.
1.
2.


do while 반복문
do {
        반복 문장들
} while ( 조건식 );

1. 반복문장들 실행
2. 조건식이 참이면 위로 올라가서 반복문장들 실행
1.
2.
1.
2.


loop {
        if ( 짝수인지 검사) {
                합산
        }
}

loop {
        짝수로만 반복을 한다.
        합산을 한다.
}

https://school.programmers.co.kr/
문제 풀이 github
https://github.com/sincerus7/springboot.git


인간이 언어를 개발하고 컴파일을 하면 운영체제에서 실행이 가능한 바이너리 코드가 생깁니다.
int i = 10; 고급언어

0xA0B1C3 => 기계코드

Java 언어
컴파일하면 *.class 파일이 생깁니다. (바이트코드)
JVM 실행
윈도우 JVM, 맥 JVM, Linux JVM
Java Virtual Machine

[접근제한자] class 클래스이름 [extends 부모클래스] [implements 부모인터페이스,...] {
        클래스를 선언합니다.
        ...
        ...
        /**
        java documents
        */
        [접근제한자] 데이터형 멤버변수1이름;
        [접근제한자] 데이터형 멤버변수2이름;
        멤버변수도 N 개 가능함


        /**
        java documents
        */
        [접근제한자] 데이터형 멤버메소드1이름(데이터형 매개변수1이름, 데이터형 매개변수2이름, ...) [throws 부모가 Throable클래스] {
                메소드를 선언합니다.
                ...
                return 데이터형;
        }

        [접근제한자] 데이터형 멤버메소드2이름(데이터형 매개변수1이름, 데이터형 매개변수2이름, ...) [throws 부모가 Throable클래스] {
                메소드를 선언합니다.
                ...
                return 데이터형;
        }
        멤버메소드는 N 개 가능함.

        @Override
        [접근제한자] 부모인터페이스의메소드(...) {
                부모인터페이스의 메소드 몸체를 구현해야 합니다
                if, for, while, ...;
        }
}


자동차 설계 {
        운전대
   운전사
       바퀴
    엔진
창문
}

컴퓨터
변수 : 값이 변하는 데이터 타입이 같은 저장공간 (variable)
int i;
i = 10;
i = 20;

상수 : 값이 변하지 않는 저장공간 (리터럴, literal)
const int i = 10;
i = 20; 컴파일에러

final int i; (클래스 생성자에서 값을 한 번만 초기화할 수 있다. 그 이후로는 변경 불가능)
생성자 {
        i = 10;
}


int i = 10;
int j = i;

String s1 = "123";
String s2 = s1;

값형 타입은 변수의 저장 공간에 '값'이 저장됩니다.
int a = 10;

참조형 타입은 변수의 저장 공간에 &주소(*변수명) 가 저장됩니다.
String s = "abcdef";

Java 배열
데이터타입[] 변수명; => 선언
데이터타입[] 변수명 = new 데이터타입[] {....}; => 선언과 초기화

데이터타입[][] 변수명 = new 데이터타입[6][5];
@ @ @ @ @ @
@ @ @ @ @ @
@ @ @ @ @ @
@ @ @ @ @ @
@ @ @ @ @ @


데이터타입[][] 변수명 = new 데이터타입[6][];
@ @ @ @ @ @

변수명[0] = new 데이터타입[4];
변수명[1] = new 데이터타입[2];
변수명[2] = new 데이터타입[3];
변수명[3] = new 데이터타입[7];
변수명[4] = new 데이터타입[8];
변수명[5] = new 데이터타입[5];

public Enum 열거형이름 {
        열거형아이템1이름,
        열거형아이템2이름,
        열거형아이템3이름,
        열거형아이템4이름,
}
Enum 은 제한된 아이템의 값만 가질수 있는 데이터 형이다.
Enum 을 int나 String 으로 기본값을 가지게 만들 수 도 있다.

객체지향의 특징
캡슐화 : 필드는 무조건 private 해야 한다. 필드값을 읽을려면 Getter, 저장할려면 Setter 를 사용해야 한다.
상속 :
다형성 :

객체의 속성 : 변수, 값, 프로퍼티, 멤버변수, 필드
객체의 동작 : 메소드, 생성자(생성할때 자동 동작하느냐 수동 동작하느냐)

HasA 관계 : 클래스 안에 클래스를 멤버변수로 가지는 형태 (집합관계)
IsA 관계 : 상속 관계
사용관계 : 객체가 다른객체의 메소드를 호출하는 형태

다형성 :
1. Overloading : 메소드의 이름은 같으나 매개변수의 형태가 다른 경우

public int add( int a, int b) {
        ...
}

public double add( double a, double b) {
        ...
}

2. Overidding : 부모메소드의 이름과 배개변수 형태가 같을지라도 자식이 그 메소드를 다시 선언해서 사용할 수 있는 경우

public class Parent {
        public void drive() {
                직선만 운행;
        }
}

public class Child extends Parent {
        public void drive() {
                우회전도 가능, 좌회전도 가능
                super.drive();
        }
}

Child c = new Child();
c.drive();

stryArray[0] = new String("Java");


차 <- 기아차 <- 모닝
클래스 (설계도, 틀, 도안, )
클래스 메소드 (정적 메소드) : static 예약어로 선언한다., new 없어도 사용 가능하다. 전체 클래스에서 1개만 존재한다.
        사용방법 => 클래스명.클래스메소드명
클래스 변수 (정적 멤버) : static 예약어로 선언한다., new 없어도 사용 가능하다. 전체 클래스에서 1개만 존재한다.
        사용방법 => 클래스명.클래스변수명

public class 모닝 extends 기아차 {
        public static final int CC = 800;
        public static void ReCall() {
                전체 모닝은 운행중단 하고 서비스센터로 입고;
        }
        private Color bodyColor;
        private Tire[] tires;
        private CarNumber carNumber;
        Getter...
        Setter...
        public void run() {
                달린다.;
        }

        public 모닝() {
                // 기본생성자 (Java 가 자동으로 만들어준다. 개발자가 명시적으로 선언하면 선언한 기본생성자를 실행한다.)
                // 모닝 서울22차9821 = new 모닝();
        }

        public 모닝(Color color) {
                // 사용자 정의 생성자 (개발자가 선언한다. 이것이 존재하면 Java 가 자동으로 만들어주는 기본생성자는 사용 불가능)
                this.bodyColor = color;
                // 모닝 서울22차9821 = new 모닝(노랑);
        }

        public 모닝(Color color, Tire[] tires) {
                // 사용자 정의 생성자 (개발자가 선언한다. 이것이 존재하면 Java 가 자동으로 만들어주는 기본생성자는 사용 불가능)
                // this.bodyColor = color;
                this(color);
                this.tires = tires;
                // 모닝 서울22차9821 = new 모닝(노랑, new Tire[] {160, 160, 160, 160});
        }

        public 모닝(Color color, Tire[] tires, CarNumber carNumber) {
                // 사용자 정의 생성자 (개발자가 선언한다. 이것이 존재하면 Java 가 자동으로 만들어주는 기본생성자는 사용 불가능)
                // this.bodyColor = color;
                // this.tires = tires;
                this(color, tires);
                this.carNumber = carNumber;
                // 모닝 서울22차9821 = new 모닝(노랑, new Tire[] {160, 160, 160, 160}, new CarNumber("서울22차9821"));
        }

        [접근제한자] 리턴하는데이터타입 메소드이름(데이터타입 매개변수1이름, 데이터타입 매개변수2이름, ...) {
                메소드에서 실행할 내용 문장들;
                ....
        }

        public String aaa() {
                // 메소드에서 실행할 내용 문장들;
                ....
                String s = "abcd";
                int i = 10;
                return Integer.parseInt(s);
        }

        public void add(String name, int ... num) {

        }
}
모닝.CC
모닝.ReCall();

접근제한자
public : 모두다 접근 가능
protected : 직계 자손만 접근 가능 (자식들이 super로 사용 가능함)
private : 나(this)만 접근 가능


서울22차9821
객체 (클래스에 의하여 실제로 힙 메모리에 생성되는 실체적인 참조형태 값)
인스턴스 메소드(멤버메소드) : new 로 생성된 객체 안에 존재하는 메소드.
        사용방법 => 객체변수명.메소드명(....)
인스턴스 변수 (필드,멤버변수,객체변수) : new 로 생성된 객체안에 존재하는 변수.
        사용방법 => 객체변수명.Getter, 객체변수명.Setter 이용하는게 최선

모닝 서울22차9821 = new 모닝();
서울22차9821.run();
서울22차9821.setColor(빨강);
서울22차9821.color = 빨강; // 멤버변수를 public 으로 하고 직접 접근하는 방법인데 이 방법은 아주 사악하다.

Car ccc = new Car("그랜저", "파랑");

https://github.com/sincerus7/sangbong3_1.git
https://github.com/sincerus7/sangbong3_2.git
https://github.com/sincerus7/sangbong3_3.git
https://github.com/sincerus7/sangbong3_4.git

ArrayList : Java 의 1차원적인 배열 컬렉션
배열에 값을 추가 => 길이가 늘어납니다.
배열에 값을 삭제 => 길이가 감소합니다.
배열의 길이를 알고자 할때는 size() 사용합니다.
ArrayList 는 List 인터페이스를 상속 받은 클래스

List<데이터타입> 변수명 = new ArrayList<>();
ArrayList<데이터타입> 변수명 = new ArrayList<>();


부모클래스 메소드 5개

자식클래스 메소드 10개

손자클래스 메소드 7개


부모클래스 a = new 손자클래스();
a.부모메소드5개
((자식클래스)a).부모메소드10개 + 할아버지메소드5개
((손자클래스)a).자신메소드7개 + 아버지메소드10개 + 할아버지메소드5개

부모클래스 b = new 자식클래스();

부모클래스 b = new 부모클래스();
b.부모메소드5개
((자식클래스)b).자신메소드10개 + 부모메소드5개 (에러)


JSON 은 {} 표현하는 문자 서술형 객체이다. 키이름과 값으로 쌍을 이룬다. Map 인터페이스, HashMap 컬렉션, RestFul API 의 데이터 처리 기본이다.
"이름":"대부분의값을 문자열 날짜/시간/참/거짓"
"이름":숫자값
"이름":[..배열..]
"이름":{..객체..}

{
        "roots" :
        [
                {
                        "id":1,
                        "productName":"수박바\"",
                        "price":700
                },
                {
                        "id":2,
                        "productName":"'회오리바'",
                        "price":800
                }
        ]
}

Database 읽기 => Java 객체 => JSON => JavaScript 객체 => 화면
화면 => JavaScript 객체 => JSON,FORM,XML => Java 객체 => Database 저장

서버와 서버의 통신
다른 서버에서 데이터를 읽으려 한다. => RestFUL API => JSON => Java 객체 => Controller => Service/Service Implement/Repository => Database


json-simple 라이브러리
gson 라이브러리
jackon 라이브러리


public enum EColor {
        White,
        Black,
        Gray,
        Blue,
        Red,
}

public class Phone {
        private String model;
        private EColor color;
        private int makeYear;

        // model 의 Getter
        public String getModel() {
                return this.model;
        }

        // model 의 Setter
        public void setModel(String model) {
                this.model = model;
        }

        // color 의 Getter

        // color 의 Setter

        // makeYear 의 Getter
        public int getMakeYear() {
                if ( this.makeYear <= 2020 ) {
                        유효하지 않는 값은 유효한 값으로 변화하여 리턴한다.
                }
                return this.makeYear;
        }

        // mmakeYearodel 의 Setter
        public void setMakeYear(int makeYear) {
                if ( this.makeYear <= 2020 ) {
                        유효하지 않는 값은 저장하지 않는다.
                }
                this.makeYear = makeYear;
        }
}


phone
model varchar(10),
color varchar(5),
make_year int,


부모생성자 호출할때는 super(...); // 자신의 생성자에서만 호출 가능하다. (생성자에서만 생성자를 호출 할 수 있다.)
부모메소드 호출할때는 super.메소드명(...);


객체지향의 다형성은 Overloading, Overidding, 추상클래스 활용, 인터페이스 활용 등등

부모클래스 타입을 사용하여 서로다른 자식객체를 변환하여 사용한다.



BC 카드, Master 카드, 삼성카드, NH카드, KB카드, 신한카드, 유니온페이, 카카오페이....

public interface 카드 {
        boolean 결제한다(카드번호, 유효기간, 소유주명, 3자리넘버, 금액);
}


public class BC카드 implements 카드 {
        @Override
        public boolean 결제한다(카드번호, 유효기간, 소유주명, 3자리넘버, 금액) {
                BC카드 서버에 접속한다.
                카드번호가 유효한지 체크한다.
                유효기간 체크한다.
                실패하면 false
                ...
                성공하면 true 리턴
        }
}


public class Master카드 implements 카드 {
        @Override
        public boolean 결제한다(카드번호, 유효기간, 소유주명, 3자리넘버, 금액) {
                Master카드 서버에 접속한다.
                ....
                실패하면 false
                ...
                성공하면 true 리턴
        }
}


public class 결제하는클래스 {
        BC카드 bcCard = new BC카드();
        Master카드 masterCard = new Master카드();
        카드 paycard;

        public 사용자결제(카드종류, 카드번호, 유효기간, 소유주명, 3자리넘버, 금액) {
                if (카드종류 == BC) {
                        paycard = bcCard;
                        paycard.결제한다(카드번호, 유효기간, 소유주명, 3자리넘버);
                } else if (카드종류 == 마스터카드) {
                        paycard = masterCard;
                        paycard.결제한다(카드번호, 유효기간, 소유주명, 3자리넘버);
                }
        }
}

C -> B -> A
E -> D -> A
        A 메소드 : 2개 껍데기만, a1, a2
        B 클래스 : A 메소드2개 구현, 1개 메소드 b1
        C 클래스 : A 메소드2개 구현, 2개 메소드 c1, c2
        D 클래스 : B 클래스 상속, 2개 메소드 d1, d2
        E 클래스 : C 클래스 상속, 2개 메소드 e1, e2

        A aaa = new D();

        A a = (A)aaa; // a.a1(), a.a2()
        B b = (B)aaa; // b.a1(), b.a2(), b.b1();
        D d = (D)aaa; // d.a1(), d.a2(), d.b1(), d.d1(), d.d2()
        C c = (C)aaa; // c.a1(), c.a2(), c.c1(), c.c2() ----> Error
        E e = (E)aaa; // e.a1(), e.a2(), e.c1(), e.c2(), e.e1(), e.e2() ----> Error

        
        A aaa = new B();
        A aaa = new C();
        A aaa = new D();
        A aaa = new E();
        
예외처리 : 프로그램이 특정 예외가 발생하는 경우에 프로그래머가 처리할 수 있도록 하는것

Exception 은 Database, 비지니스 로직의 시작과 끝 Transaction 이 완료 됩니다.
RuntimeException 은 Transaction 을 Rollback 하거나 commit 하는것이 개발자가 처리할 수 있다.

예외처리를 개발자가 핸들하려면

try ~ catch ~
try ~ catch ~ ... catch ~
try ~ catch ~ ... catch ~ finally ~~

try{
        개발자가 코딩을 하는게 있어서 이 부분에서 예외가 발생할지도 모르는 블록
        ...
        ...
        ...
} catch ( 예외클래스A 변수명 ) {
        예외클래스A 데이터타입의 예외가 발생했을때 이 부분이 자동으로 실행됨
        ...
} catch ( 예외클래스B 변수명 ) {
        예외클래스B 데이터타입의 예외가 발생했을때 이 부분이 자동으로 실행됨
        ...
} catch ( 예외클래스C 변수명 ) {
        예외클래스C 데이터타입의 예외가 발생했을때 이 부분이 자동으로 실행됨
        ...
} finally {
        try 블록이 모두 실행됐을때 finally 가 실행됨
        try 블록 실행중에 예외가 발생하여서 catch 가 실행되었을때 catch 가 실행된 후에 finally 실행됨
}
예외클래스A (손자) 예외클래스B (아들, A예외클래스와 무관) 예외클래스C(할아버지, A, B예외클래스와 무관)

try 실행 하다가 A 예외가 발생하면 : try{} => catch(예외클래스C) {} => finally{}
try 실행 하다가 B 예외가 발생하면 : try{} => catch(예외클래스B) {} => finally{}
try 실행 하다가 C 예외가 발생하면 : try{} => catch(예외클래스C) {} => finally{}
try 실행 하다가 예외가 없다면 : try{} => finally{}



JSON 파일 저장하고 읽기
1. 라이브러리가 필요하다. json-simple 을 maven 의 POM.xml 에 추가 하거나 gradle 의 build.gradle 에 추가해야 한다.
2. 구글에서 maven repository 를 검색하여 maven repository 홈페이지에 접속하고 json-simple 을 검색한다.
3. Usages 가 가장 많은 버전을 선택하여, pom.xml 이나 build.gradle 의 문장을 복사한다.
4. 자신의 프로젝트 pom.xml이나 build.gradle 에 붙여넣기를 하고 Maven update 또는 gradle refresh 를 한다.


BankApplication 에 파일 읽기6번, 파일쓰기7번을 추가한다.
AccountJSONRepository 클래스를 생성한다. AccountJSONRepository 에
      loadJson(JSON 파일 ===> Java 객체배열), saveJson(Java 객체 배열 ==> JSON 파일) 메소드를 생성한다.

BankApplication 에서 화면에 출력하고 키보드로 입력하는 부분을 코딩한다.
AccountJSONRepository 에서는 화면에 출력하고 키보드로 입력하는 부분을 코딩하지 않습니다.
loadJson(파일이름),  saveJson(파일이름) 을 호출한다.


MVC 소프트웨어공학의 개념은
Model(객체,데이터) 과 View(화면) 와 Controller(제어,비지니스)의 영역을 분리해서
향후 소프트웨어 재사용을 높이고 문제 해결을 쉽게 합니다.


1. JSP, PHP 에서 사용자 행동하는 기능
2. 1~2개의 jsp, php 파일 안에서 화면과 DB 의 데이터를 읽거나 쓰는 동작을 직접 구현합니다.

Spring framework 또는 전자정부 프레임워크 에서는 
0. WEB 화면, Mobile (HTML, CSS, JavaScript, Vue.js, React.js, Angular.js, TypeScript, BootStrap, Flutter, ...)
1. Controller : HTTP POST, GET, PATCH, DELETE 이러한 사용자가 행동하는 기능을 구현합니다.
2. Service : Service Implement 의 interface 를 구현합니다. (개발회사 마다 약간씩 다름)
3. Service Implement : 데이터 객체를 DAO 에서 저장하거나 읽을수 있도록 하는 기능을 구현합니다.
4. Data Access Object (DAO) : Database 에 접속하여서 데이터를 저장하거나 읽습니다. MyBatis 안에 SQL 언어
5. Model (데이터 객체, 자바빈)
6. ORACLE, MSSQL, DB2, MySQL, ... : DBMS 


Spring Boot 프레임워크 에서는 (Python Django 프레임워크)
0. WEB 화면, Mobile (HTML, CSS, JavaScript, Vue.js, React.js, Angular.js, TypeScript, BootStrap, Flutter, ...)
1. Controller : HTTP POST, GET, PATCH, DELETE 이러한 사용자가 행동하는 기능을 구현합니다.
2. Service : Service Implement 의 interface 를 구현합니다. (개발회사 마다 약간씩 다름)
3. Service Implement : 데이터 객체를 Repository 에서 저장하거나 읽을수 있도록 하는 기능을 구현합니다.
4. Repository : 실제 저장공간(Database, 파일, 액셀, NOSQL 등) 에 접속하여서 데이터를 저장하거나 읽습니다.
5. Model (데이터 객체, 자바빈)
6. ORACLE, MSSQL, DB2, MySQL, NoSQL, JSON, Excel, File, ...



상속관계에서의 데이터형변환 예제
잉꼬새 -> 새 -> 조류 -> 동물
강아지 -> 애완용 -> 포유류 -> 동물
악어 -> 포식자 -> 양서류 -> 동물
뱀 -> 포식자 -> 양서류 -> 동물
고양이 -> 애완용 -> 포유류 -> 동물

양서류 메소드A(동물) {
        동물.메소드 를 실행
        return new 양서류;
}

동물 d = 메소드A(악어);


동물 메소드B(포유류) {
        포유류.메소드를 실행;
        return new 악어/뱀/포식자;
}

양서류 p = (양서류)메소드B(고양이);


모든 프로그램 개발자는 CRUD 를 제대로 에러 없이 만들어야 하는게 기본기 입니다.
C => Create, HTTP POST, Controller -> SeriveImple -> Service -> Repository/DAO -> DB(insert 생성)
R => Read, HTTP GET, Controller -> SeriveImple -> Service -> Repository/DAO -> DB(select 검색, 조회)
U => Update, HTTP PATCH, " (update 수정)
D => Delete, HTTP DELETE, " (delete 삭제)

모든 언어의 프로그래머 개발자의 기본 자질은 데이터형/데이터타입 을 제대로 맞추는데에 있다.
리턴데이터타입 메소드(매개변수데이터타입 변수명, ...)

Lombok 의 @Builder 의 역할

클래스를 객체로 인스턴스할때 모든 필드의 값을 초기화 할수도 있고,
 어떤 필드의 값을 초기화 할수도 있는 매우 유용한 생성 메소드이다.

        IPhoneBook phoneBook = PhoneBook.builder()
                .id(this.getMaxId())
                .name(name).group(group)
                .phoneNumber(phoneNumber).email(email).build();

        클래스명.builder().필드(값).필드2(값).필드3(값).....build();

// 클래스의 기본생성자로 객체를 인스턴스하고 Setter 로 필드의 값을 저장하는 형태
//        IPhoneBook phoneBook = new PhoneBook();
//        phoneBook.setId(this.getMaxId());
//        phoneBook.setName(name);
//        phoneBook.setGroup(group);
//        phoneBook.setPhoneNumber(phoneNumber);
//        phoneBook.setEmail(email);

// 클래스의 비기본생성자로 객체를 인스턴스하고 필드의 값을 초기화하는 형태
//        IPhoneBook phoneBook = new PhoneBook(
//                this.getMaxId()
//                , name
//                , group
//                , phoneNumber
//                , email
//        );

jar 파일 실행하는 명령어
$>java -jar 실행할jar파일이름



WireShark

OSI 7 Layer 중의 Data Layer
IPv4 : 4 바이트로 이루어진 주소
0.0.0.0 ~ 255.255.255.255
A클래스 : A.*.*.*       5.1.2.3,  5.32.38.109
        최대 16,777,216개 장비가 하나의 네트워크에 구성되어 있다.
B클래스 : A.B.*.*       61.182.2.3,  61.182.92.11
        최대 65,536개 장비가 하나의 네트워크에 구성되어 있다.
C클래스 : A.B.C.*       84.23.192.5, 84.23.192.7
        최대 256개 장비가 하나의 네크워크에 구성되어있습니다.

Hub : 같은 네트워크에 장비들을 연결하는 역할 장비, 100Mbps 포트4개이면 각각 최대 25Mbps
switch : 같은 네트워크에 장비들을 연결하는 역할 장비, 100Mbps 포트n개 라도 각각 최대 100 Mbps

Router : IP 주소 클래스가 다르거나 SUB NETWORK 로 구분된 네트워크망 사이의 프로토콜 전송을 하는 장비
Gateway : Router 기능 + 프로토콜 번역하고 변환 장비



https://www.codeup.kr/problem.php?id=1905
https://www.codeup.kr/problem.php?id=1916
https://www.codeup.kr/problem.php?id=1953
https://www.codeup.kr/problem.php?id=3702
https://www.codeup.kr/problem.php?id=3733

재귀함수를 만드는법
자기자신 함수를 호출할때 종료 조건이 가능한 매개변수나 리턴값을 항상 처리해야한다.

종료조건이 어떤 값 이상일때 자기자신함수를 호출할때마다
 매개변수값은 어떤값 이상이 되도록 값의 변화를 줘야한다.

1,1,2,3,5,8,13,21,34,55,89,144
…




GIT (형상관리툴)
원격저장소 (Remote Repository) : github, gitlab, bitbucket 등등 (조직내에서 서버를 구축할수 있다.)
지역저장소 (Local Repository) : 로컬PC에 gitscm 을 다운로드하여서 설치하면 로컬저장소를 만들수있고 원격저장소와 자료 저장과 로드가 된다.

*** git 초기에 하는것
1. 원격저장소에서 repository를 생성한다. git 원격저장소 주소가 생깁니다.
2. 로컬PC에서 git 명령으로 git clone 원격저장소주소 하면 해당 폴더 하위폴더에 git 로 관리 가능한 로컬저장소가 생깁니다. (.git 폴더)

1. 로컬pc 에서 git 명령으로 git init 를 하면 해당 폴더가 git 관리 가능한 로컬 저장소가 생깁니다. (.git 폴더)
2. 원격저장소의 repository 에 있는 주소를 가지고 로컬pc 로컬저장소 폴더에서 git remote add 명령을 하면 원격저장소와 연결이 됩니다.
3. 이 부분은 로컬과 원격의 폴더와 파일이 다르면 위험하다.

개발자는 각각 자기의 로컬에 작업을 합니다. (작업할때 git 충돌이 발생하지 않도록 팀별로 규칙을 정합니다.)

매일 아침이나 또는 오후시작할때 또는 push 하기 전에 항상
 fetch (원격저장소의 파일을 가져오진 않지만 히스토리 정보나 달라진 정보를 가져옵니다.)
 pull (원격저장소의 최신 파일을 가져옵니다.)
을 합니다.

프로그램 개발 작업을 하면서 자주 형상을 기록하기 위해서 로컬저장소에 commit 합니다.
에러가 없으면 원격저장소에 push 를 합니다.


git 브랜치
git 는 main 또는 master 라는 기본 브랜치가 있습니다.
로컬이나 원격에서 브랜치를 만들수가 있습니다. git checkout -b 새로운브랜치이름

각각 브랜치를 이동할때는 git checkout 브랜치이름

브랜치를 사용하는 이유는 작업하는 상황에서 어떤 파일들의 상황(버전,형상)을 잠시 보관하고자 할때 사용 합니다.
또는 그 형상을 계속 보관하고 개발하려고 사용합니다.
브랜치를 통해서 개발을 진행하다가 main 이나 master 에 병합을 해야 합니다.

PhoneBook (main) (makeKakaoId)

main
|
|
|--------|
main     makeKakaoId(브랜치생성)
|        |
|        |
|        |
|        |
|        |------------|
main     makeKakaoId  makeKakaoGeoMap(브랜치생성)
|        |            |
|        |            |
|        |            |
|        |------------|
|        |makeKakaoId + makeKakaoGeoMap (브랜치병합, Merge)
|        |
|        |
|--------|
|
|
main (makeKakaoId 브랜치와 병합, merge)





이슈관리 툴
Jira (Bitbucket 회사)


협업의사소통 툴
Slack (의사소통, 지식고유, 일정관리)


형상관리 툴
git


배포툴
jenkins => git (main, master) 소스를 가져와서 빌드한다 => 개발서버에 배포를 한다. => 개발서버 테스트 => 운영서버에 배포를 한다.


CI/CD
jenkins
IDE
git
문제발생 => 이슈등록 이슈담당자할당 




create database phonebook_db character set utf8mb4 collate utf8mb4_general_ci;
create user 'phonebook_user'@'%' identified by 'sangbong3!';
grant all privileges on phonebook_db.* to 'phonebook_user'@'%' with grant option;
flush privileges;

create database egoventerprise_db character set utf8mb4 collate utf8mb4_general_ci;
grant all privileges on egoventerprise_db.* to 'phonebook_user'@'%' with grant option;
flush privileges;

create database egovsimple_db character set utf8mb4 collate utf8mb4_general_ci;
grant all privileges on egovsimple_db.* to 'phonebook_user'@'%' with grant option;
flush privileges;

create database egovportal_db character set utf8mb4 collate utf8mb4_general_ci;
grant all privileges on egovportal_db.* to 'phonebook_user'@'%' with grant option;
flush privileges;


# MySQL8 설정
spring.datasource.url=jdbc:mysql://localhost:3306/phonebook_db?useSSL=false&characterEncoding=UTF-8&serverTimezone=UTC
spring.datasource.username=phonebook_user
spring.datasource.password=sangbong3!
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# 콘솔에 SQL 출력 여부
spring.jpa.database-platform=org.hibernate.dialect.MySQLDialect
spring.jpa.show-sql=true

# hibernate 설정
spring.jpa.database=mysql
spring.jpa.hibernate.ddl-auto=update
spring.jpa.hibernate.naming.strategy=org.hibernate.cfg.ImprovedNamingStrategy
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
spring.jpa.generate-ddl=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true



=== Category 테이블을 추가하고 클래스를 추가해야 할때 ====
ICategory : Dto, Entity 에서 상속받을 getter, Setter.
CategoryDto, CategoryEntity : 생성하세요.
CategoryJpaRepository : PhoneBookJpaRepository 를 참고해서 만들어요.
ICategoryService : IPhoneBookService 를 참고해서 만들어요.
CategoryServiceImpl : PhoneBookServiceImpl 을 참고해서 만들어요.
CategoryController : PhoneBookController 를 참고해서 만들어요.



일반적 Java Web Project 폴더구조
src
    main
        java
            java 패키지/소스들
        resources
            Web 이 실행되는 자원들 (설정파일, 화면파일, css 파일, JavaScript 파일, 그림파일, Mybatis sql xml)
        webapp
            JSP 파일, html 파일
    test
        (Junit test : java package 구조랑 같아야 한다.)


Mybatis 규칙
        Mybatis 를 정의하는 java interface 소스파일 안의 메소드이름, 매개변수데이터형 과
        Mybatis xml 파일
                <insert id="메소드이름" parameterType="매개변수데이터형"
                <update id="메소드이름"
                <delete id="메소드이름"
                <select id="메소드이름"
        이 같아야 한다.



1. Server => New => Apache Tomcat 9 생성
2. Tomcat 의 Context 에 프로젝트 추가
3. Tomcat 9 의 Port 번호 변경
4. Project 메뉴 => Clean 또는 Build All
5. Server => Debug 시작 (에러시 에러 해결)
6. 브라우저에서 http://localhost:Port번호/Context에 추가된 프로젝트명 으로 접속
7. Database 는 메모리 DB 이므로 Tomcat 재시작하면 데이터가 다시 초기화됨
8. resources => egovframework => spring => context-datasource.xml 파일에서
 HSQL 을 주석처리 하고 Mysql 을 주석 해제한다.
9. Mysql 관련 라이브러리 commons-dbcp, mysql-connector-java 를 maven repository 에서 찾는다.
10. pom.xml 에 관련라이브러리를 추가한다.
11. context-datasource.xml 파일에 driverClassName, url, username, password 을 맞게 수정한다.
12. 4번으로 올라가서 Project => Clean 또는 Build All 한다. 6번까지 실행한다.
13. *.war 파일로 만들어야 한다.
14. *.war 파일을 Tomcat 설치 디렉토리의 webapp 폴더에 복사한다.
15. Tomcat\bin\startup.bat 를 실행한다. Port 충돌시 conf\server.xml 에서 포트번호 수정
16. Tomcat 에러 발생 시 에러 해결하고 브라우저에서 확인한다. http://localhost:포트번호/*.war 파일명
17. Tomcat\bin\shutdown.bat 를 실행하여 Tomcat 중지 확인한다.




전자정부프레임워크 초기 프로젝트 생성하기

1. database 를 생성한다.
2. database 에 접속할 사용자와 권한을 설정한다.
3. 전자정부프레임워크 이클립스에서 New => Project => eGovFrame * Project 를 생성한다.
4. 프로젝트의 name, groupid 등등을 설정한다.
5. 프로젝트의 context-datasource.xml 또는 globals.properties 에서 DB 접속 url, user, password 를 설정한다.
6. database 종류에 맞는 ddl.sql 쿼리와 data.sql 쿼리를 찾아서 SQL 접속하여 스크립트 실행한다.
7. 프로젝트 clean 하고 servers 의 톰캣에 web module 을 추가하고 Debug 실행한다.
8. 로그인해서 암호 안 맞으면 로그에 있는 암호화문자열을 lettnemplyrinfo 또는 lettngnrlmber 테이블의 암호 컬럼에 수정한다.


웹 서버/서비스/앱/어플리케이션 의 기본 구조

1. 클라이언트 (브라우저, 클라이언트 프로그램) 가
        http 프로토콜로 주소(서버/서비스/앱)와 method(GET/POST/...) 로 요청 Request
2. http 주소와 method에 해당하는 서버의 Servlet, @Controller 이 요청을 받습니다.
3. Servlet/@Controller 이 요청을 받은후 서버의 메소드에서 실행을 하고
        응답(Response)을 클라이언트에 대답합니다.

서버/서비스/앱/어플리케이션 개발자
C,C++ CGI println, pintf html 문자열을 작성 해서 응답했음.
html 파일을 직접 응답하는 웹 서버 등장 (정적파일) (Apache Web Server, ..)
        => html, css, javascript, images, audio, movie 등등 정적파일을 요청한 그대로 응답한다.
        => Web Server
html 에 css 와 javascript (Client side script)동적인 화면을 만드는 파일들도 서비스합니다.
서버/서비스/앱/어플리케이션 : RDBMS, 서버 I/F 처리하고 그 결과를 html 로 만들어서 서비스합니다.
        서버사이드스크립트(Server side script) C/C++ GUI, PHP, ASP, ASPX, JSP (동적파일)
                (Apache Tomcat Server, IIS, Jeus, Web Logic)
        <%   <?   <@    <c:if, <c:while, <c:for 로직 처리
Java 스프링 프레임워크
PHP Laravel 프레임워크
ASPX C#기반의 프레임워크
Python Django 프레임워크
Ruby XXX 프레임워크
템플릿기반의 동적파일
서버사이드스크립트 + 프레임워크 기능 지원하는 웹서버 => WAS (Web Application Server)

기능 1개를 추가하는데 소모되는 시간 : 정적파일 약 8시간
기능 1개를 추가하는데 소모되는 시간 : 동적파일 약 6시간
기능 1개를 추가하는데 소모되는 시간 : 프레임워크 약 2시간

Markup Language : 문서 <tag> ~~~ </tag>
XML : 데이터를 markup 형태로 표현하는 문서 파일 root 는 1개
HTML : web 의 화면을 구성하는 문서 파일 html 이라는 root, <hr>
XHTML : html 은 end markup 이 없는 태그도 있으나 xhtml 은 end markup 을 항상 해야 한다.
        즉 html 에 xml 의 문법을 적용했다.


